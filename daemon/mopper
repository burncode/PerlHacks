#!/usr/bin/env perl

# $Id: mopper 3832 2009-10-15 06:51:52Z denneau $
# Separate support code stub for testing.

=head1 NAME

mopper - Execute MOPS pipline
 
=head1 SYNOPSIS

mopper [options] [INSTANCE_NAME]

  INSTANCE_NAME : name of simulation to run
  --mops_home DIR : use DIR as MOPS home directory; otherwise $ENV{MOPS_HOME} or /usr/local/MOPS
  --bg : run in background
  --no_env : don't set environment
  --no_run : don't run; just setup env and quit
  --email=ADDR : email notifications to ADDR
  --quiet : less output
  --help : show usage

=head1 DESCRIPTION

Runs a MOPS instance unattended by establishing MOPS environment then
calling SYNTH, TRACKLET, ATTRIB, LINKOD, and EON repeatedly until there
is no more data to process.

It is expected that jobs invoked by MOPPER conform to simple exit
code conventions, as follows:

  0 - successfully processed some data
  1 - no data to process
  2 - other MOPS failure 
  99 - internal error in job

MOPPER can be terminated in two ways via a signal.  For graceful termination,
send a SIGUSR1, which will set an internal flag to terminate MOPPER following
the completion of the current job.  Send SIGINT to attempt to shutdown MOPPER
immediately (currently unsupported).  The consistency of a simulation is not
guaranteed (yet) if it is terminated via SIGKILL.

=head1 INVOCATION RULES

1. Fetch the earliest night for which there is unfinished work.  If so,
execute the pipeline for that night.

2. If there is a datastore, then execute INGEST, then go to 1.

3. If there is no further work to do, stop.

=head1 ENVIRONMENT

MOPS execution requires the following environment variables to
be set up, so MOPPER sets them to appropriate values.

        MOPS_DBINSTANCE 
        MOPS_HOME (/usr/local/MOPS)
        PERL5LIB ($MOPS_HOME/lib/perl5)
        PATH ($MOPS_HOME/bin)
        CAET_DATA ($MOPS_HOME/data/caet_data)
        OORB_DATA ($MOPS_HOME/data/oorb)
        ORBFIT_DATA ($MOPS_HOME/data/orbfit)
        LD_LIBRARY_PATH ($MOPS_HOME/lib)

The PATH, CAET_DATA and LD_LIBRARY_PATH environment variables
are manipulated in PATH-fashion:  they new value is prepended to the
old one, separated by a colon ':'.  If the new value is found in the
old value, the environment variable is not modified.

=cut

use strict;
use warnings;

use Proc::Daemon;
use Pod::Usage;
use Sys::Hostname;
use Getopt::Long;
use Fcntl qw(:flock);
use Data::Dumper;
use Params::Validate;

use PS::MOPS::Constants qw(:all);


use subs qw(
    setup_env
    run_stage
    write_pid
    catch_SIGUSR1
    clean_up_and_exit
    _setenv
    _addenv
);


# Globals.
my $PID_FILENAME;
my $inst;
my $mops_logger;
my $mops_config;
my $have_datastore;
my @envkeys = qw(
    MOPS_HOME
    MOPS_DBINSTANCE 
    PERL5LIB
    PYTHONPATH
    PATH 
    CAET_DATA 
    OORB_DATA 
    ORBFIT_DATA 
    LD_LIBRARY_PATH 
);


# Job exit codes:
#  0 - successfully processed some data
#  1 - MOPS failure 
#  2 - exit via stop request
my $EXIT_SUCCESS = 0;
my $EXIT_ERROR = 1;
my $EXIT_STOP = 2;
my $exit_code = $EXIT_SUCCESS;


# Options.
my $instance_name;
my $mops_home;
my $bg;
my $no_update_config;
my $no_env;
my $no_run;

my $status;
my $start;
my $stop;
my $abort;
my $email;

my $quiet;
my $help;
GetOptions(
    instance => \$instance_name,    # specify instance, or use $ENV{MOPS_DBINSTANCE}
    'mops_home=s' => \$mops_home,   # specify MOPS_HOME, otherwise $ENV{MOPS_HOME} || /usr/local/MOPS
    bg => \$bg,                 	# run in background as daemon
    no_update_config => \$no_update_config,   # DON'T auto-update config
    no_env => \$no_env,             # DON'T set environment
    no_run => \$no_run,             # DON'T run, just setup env and quit (debugging)

    # Control options.
    status => \$status,
    start => \$start,
    stop => \$stop,
    abort => \$abort,

    # Notification options.
    'email=s' => \$email,
    quiet => \$quiet,

    help => \$help,
) or pod2usage(2);
pod2usage(-verbose => 2) if $help;
$instance_name ||= shift || $ENV{MOPS_DBINSTANCE};
pod2usage(3) unless $instance_name;
pod2usage(-message => '--abort is not supported yet.') if $abort;


# Set up our stage data.
my %stage_config = (
    INGEST => {
        CMD => 'ingest',
    },
    SYNTH => {
        SKIP_STATUS => { 
            $FIELD_STATUS_INGEST => 1,
            $FIELD_STATUS_TRACKLETS_DONE => 1,
            $FIELD_STATUS_ATTRIBUTIONS => 1,
            $FIELD_STATUS_LINK1 => 1,
        },
        CMD => 'synth',
        NN => 1,
    },
    TRACKLET => {
        SKIP_STATUS => { 
            $FIELD_STATUS_TRACKLETS_DONE => 1,
            $FIELD_STATUS_ATTRIBUTIONS => 1,
            $FIELD_STATUS_LINK1 => 1,
        },
        CMD => 'tracklet',
        NN => 1,
    },
    ATTRIB => {
        SKIP_STATUS => { 
            $FIELD_STATUS_ATTRIBUTIONS => 1,
            $FIELD_STATUS_LINK1 => 1,
        },
        CMD => 'panda --attrib',
        NN => 1,
    },
    LINKOD => {
        SKIP_STATUS => { 
        },
        CMD => 'linkod',
        NN => 1,
    },
    EON => {
        CMD => 'eon',
        NN => 1,
    },
);


# Set up MOPS environment.
unless ($no_env) {
    setup_env($instance_name);
}


# Interrogate whether there's an already running mopper.
unshift @INC, "$ENV{MOPS_HOME}/lib/perl5"; # yech
require PS::MOPS::DC::Instance;     # now load, after %ENV set up
$inst = PS::MOPS::DC::Instance->new(DBNAME => $instance_name);
$mops_logger = $inst->getLogger;
$PID_FILENAME = sprintf "%s/run/mopper.pid", $inst->getEnvironment('VARDIR');


if ($status) {  
    # Just report where we left off, or what there is to do.
    my $field = $inst->getOldestUnfinishedField();
    if ($field) {
        printf STDERR "%s: oldest unprocessed field ID: %d(%s) NN/OCNUM %d/%d \n", 
            $inst->dbname, $field->fieldId, $field->status, $field->nn, $field->ocnum;
    }
    else {
        print STDERR "%s: no fields to process.\n", $inst->dbname;
    }
    exit;
}


# Query the lock file to find out if mopper is already running for this instance.
if (get_lock($inst)) {
    # Fetch PID.
    my $pid_fh = new FileHandle $PID_FILENAME or 
        $mops_logger->logdie("Can't find PID file for " . $inst->dbname . ".\n");
    my $pid = <$pid_fh>;
    chomp $pid;
    $mops_logger->logdie("Bogus PID in PID file $PID_FILENAME.") unless $pid =~ /^\d+$/;

    print STDERR "Found a running mopper for " . $inst->dbname . " with PID $pid.\n";


    # Handle a stop/abort request.
    if ($stop) {
        print STDERR "Sending stop notification (SIGUSR1) to running mopper...";
#        my $num = kill(-10, $pid);        # -10 = -USR1 => entire process group
        my $num = kill('USR1', $pid);        # -10 = -USR1 => entire process group
        print STDERR "sent.\n";
        if ($num != 1) {
            print STDERR "Seems to be dead.\n";
        }
    }
    exit;
}


# Dump the environment variables.
unless ($quiet) {
    print STDERR "MOPS environment set up.\n";
    print STDERR "  $_=$ENV{$_}\n" foreach @envkeys;
}


# Update the config from the master config if it's changed.
unless ($no_update_config) {
    system("editConfig --install") == 0 or die "can't update config";
}


# Now re-load instance to get updated config.
$inst = PS::MOPS::DC::Instance->new(DBNAME => $instance_name);
$mops_logger = $inst->getLogger();
$mops_config = $inst->getConfig();

# Set up notifications.
$email ||= $mops_config->{main}->{notify};
$email = '' if $email =~ /^none$/i;

# See if we have a datastore.  If no, bypass all ingest processing.
$have_datastore = ($mops_config->{ingest}->{root_url} or $mops_config->{ingest}->{index_url});


if ($no_run) {
    # Debugging.
#    print Dumper($inst);
    exit;
}


# Daemon setup.
print STDERR "Ready to run simulation '$instance_name'.  Have a great day.\n";
Proc::Daemon::Init if $bg;          # daemonize if specified
$SIG{USR1} = \&catch_SIGUSR1;       # set up SIGUSR1 handler
write_pid($inst);


# Main processing loop.  See POD above for details.
my $quit;               # asked to quit via SIGUSR1
my $field;              # oldest field with work to do
my $nn;

# First see if there's any work to do.
eval {
    $field = $inst->getOldestUnfinishedField();

    if (!$field) {
        # We didn't find anything to do, so try INGEST.
        if ($have_datastore) {
            run_stage('INGEST');
            $field = $inst->getOldestUnfinishedField();
        }
    }

    while ($field) {
        # Run the pipeline. 
        $nn = $field->nn;

        # We check the status of the last processed field, as reported by
        # getOldestUnfinishedField().  This allows us to continue where we left
        # off -- the first time through the while() loop, we skip everything
        # until we reach the stage after $last_status.
        my $last_status = $field->status;

        run_stage('SYNTH', $nn, $last_status);
        run_stage('TRACKLET', $nn, $last_status);
        run_stage('ATTRIB', $nn, $last_status);
        run_stage('LINKOD', $nn, $last_status);
        run_stage('EON', $nn);
        notify_eon($email, $field, "Night $nn completed.");

        if ($have_datastore) {
            run_stage('INGEST');
        }
        $field = $inst->getOldestUnfinishedField();
    }
};

print "BLEH\n";

if ($@) {
    notify_error($@);
    $mops_logger->logwarn($@);
    $exit_code = $EXIT_ERROR;
}
else {
    notify_terminated('Processing completed');
    $mops_logger->info('done');
}

clean_up_and_exit($exit_code);


sub clean_up_and_exit {
    my ($rv) = @_;
    unlink $PID_FILENAME or $mops_logger->warn("Could not unlink pid file $PID_FILENAME.");
    exit($rv or 0);
}


sub catch_SIGUSR1 {
    # Just set the quit flag when SIGUSR1 received.
    $quit = 1;
}


sub run_stage {
    # Run program in job_str.  Return the job's exit value, where 0 usually means
    # something was processed successfully.  We now are always executing run_stage()
    # under eval{}, so just die if there's a problem, and it will be handled upstream.
    my ($stage, $nn, $last_status) = @_;
    my $rv;
    my $exit_code;

    
    # Decide, based on $last_status, whether we need to run this stage.
    # $last_status allows us to complete interrupted lunations where we left
    # off mid-lunation.  If our stage does not specify a START_STATUS, or
    # $last_status was not specified, we fall out of the if{} block and simply
    # continue.
    my $skip_map = $stage_config{$stage}->{SKIP_STATUS};
    if ($skip_map and $skip_map->{$last_status}) {
        $mops_logger->info("Skipping $stage $nn.");
        return $EXIT_SUCCESS;
    }

    # Build our command string.
    my $job_str = $stage_config{$stage}->{CMD}
        or $mops_logger->logdie("can't get job command for $stage");

    if ($stage_config{$stage}->{NN}) {
        $mops_logger->logdie("--nn in job command but nn is undef") unless $nn;
        $job_str .= " --nn $nn";
    }

    eval {
        $0 = "MOPPER $instance_name : $stage" . ($nn ? " $nn" : ''); 
#        print STDERR "Executing $job_str\n";
        $mops_logger->info("mopper: executing $job_str");
        $rv = system($job_str);
        $exit_code = $rv ? ($? >> 8) : 0;
        if ($exit_code != $EXIT_SUCCESS) {
            $mops_logger->logdie("$job_str failed: $?");
        }
    };

    # Perl/Unix exit value handling.  Need to extract process exit code from
    # system return value.
    die($@) if $@;           # Perl error
    if ($? == -1) {         # exec failed
        die "exec failed: $!";
    }
    elsif ($? & 127) {
        die "child failed: $!";
    }
    else {
        # Non-fatal exit codes (should be 0 and 1).
        $rv = $? >> 8;          # process exit code
        if ($quit) {
            $mops_logger->info("STOP was requested.\n");
            clean_up_and_exit($EXIT_STOP);
        }
        return $rv;
    }
}


sub setup_env {
    # Set up our environment for running MOPS simulations.
    my $inst_name = shift;

    my $MOPS_VAR = "$ENV{MOPS_HOME}/var/$ENV{MOPS_DBINSTANCE}";        # home dir for simulation
    _setenv('MOPS_DBINSTANCE', $inst_name);
    _setenv('MOPS_HOME', $mops_home || $ENV{MOPS_HOME} || '/usr/local/MOPS');

    _setenv('PERL5LIB', $ENV{PERL5LIB} || "$ENV{MOPS_HOME}/lib/perl5");
    _addenv('PERL5LIB', "$MOPS_VAR/lib/perl5");

    _setenv('PYTHONPATH', $ENV{PYTHONPATH} || "$ENV{MOPS_HOME}/lib/python");
    _addenv('PYTHONPATH', "$MOPS_VAR/lib/python");

    _addenv('PATH', "$ENV{MOPS_HOME}/bin");
    _addenv('PATH', "/usr/local/condor/bin");
    _addenv('PATH', "$ENV{MOPS_HOME}/var/$ENV{MOPS_DBINSTANCE}/bin");

    _addenv('LD_LIBRARY_PATH', "$ENV{MOPS_HOME}/lib");
    _addenv('LD_LIBRARY_PATH', "$MOPS_VAR/lib");

    _setenv('CAET_DATA', $ENV{CAET_DATA} || "$ENV{MOPS_HOME}/data/caet_data");
    _setenv('OORB_DATA', $ENV{OORB_DATA} || "$ENV{MOPS_HOME}/data/oorb");
    _setenv('ORBFIT_DATA', $ENV{ORBFIT_DATA} || "$ENV{MOPS_HOME}/data/orbfit");
}


sub get_lock {
    # Set an advisory lock to indicate mopper is running.  Return the flock return
    # code, where zero indicates we were able to obtain the lock, and non-zero
    # means a mopper is probably running.
    my ($inst) = @_;
    my $lock_filename = sprintf "%s/run/mopper.lock", $inst->getEnvironment('VARDIR');
    open LOCKFILE, "+>$lock_filename" or $mops_logger->logdie("can't open lockfile $lock_filename");
    my $rv = flock(LOCKFILE, LOCK_EX | LOCK_NB);
    return !$rv;
}


sub write_pid {
    # Write our process's pid to the runtime directory.  Note we have to do this
    # after we are daemonized so that we write the correct PID.
    my ($inst) = @_;
    my $pid_fh = new FileHandle ">$PID_FILENAME" or $mops_logger->logdie("can't open file $PID_FILENAME");
    print $pid_fh "$$\n";
    $pid_fh->close();
}


sub notify_eon {
    use Mail::Send;
    my ($addr, $field, $msg) = @_;
    return unless $addr and $field and $msg;

    my $nn = $field->nn;
    my $ocnum = $field->ocnum;
    my $dbname = $field->{_inst}->dbname();
    my $hostname = hostname();          # from Sys::Hostname

    my $mail = new Mail::Send;
    $mail->to($addr);
    $mail->subject("Notification for $dbname: $ocnum/$nn");

    my $fh = $mail->open();
    print $fh <<"EOM";
$msg

Hostname: $hostname
MOPS Instance: $dbname
Night: $ocnum/$nn

Aloha,
MOPS
EOM

    $fh->close();       # send it
    $mops_logger->info("Sent EON notification to $addr");
}


sub notify_error {
    use Mail::Send;
    my ($addr, $inst, $msg) = @_;
    return unless $addr and $inst and $msg;

    my $dbname = $inst->dbname();
    my $mail = new Mail::Send;
    $mail->to($addr);
    $mail->subject("Error termination for $dbname");

    my $fh = $mail->open();
    print $fh <<"EOM";
$msg

MOPS Instance: $dbname

Aloha,
MOPS
EOM

    $fh->close();       # send it
    $mops_logger->info("Sent EON notification to $addr");
}


sub notify_terminated {
    use Mail::Send;
    my ($addr, $inst, $msg) = @_;
    return unless $addr and $inst and $msg;

    my $dbname = $inst->dbname();
    my $mail = new Mail::Send;
    $mail->to($addr);
    $mail->subject("Processing terminated for $dbname");

    my $fh = $mail->open();
    print $fh <<"EOM";
$msg

MOPS Instance: $dbname

Aloha,
MOPS
EOM

    $fh->close();       # send it
    $mops_logger->info("Sent termination notification to $addr");
}


sub _setenv {
    my ($k, $v) = @_;
    $ENV{$k} = $v;
}


sub _addenv {
    # Add the specified item to the environment PATH-style.
    # First check to see if the thing we're adding is already there; if so, don't
    # do anything.
    my ($k, $v) = @_;
    my $re = qr/$v/;            # save regexp

    if (!$ENV{$k}) {
        $ENV{$k} = $v;          # wasn't set, so set it
    }
    else {
        my @stuff = split /:/, $ENV{$k};
        foreach my $item (@stuff) {
            return if $item =~ $re;     # found it, so bail
        }
        $ENV{$k} = join ':', $v, @stuff;
    }
}

